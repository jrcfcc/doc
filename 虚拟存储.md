### 虚拟内存管理

 **地址空间**

​		进程要运行,必须加载到内存中,操作系统会分配一段地址空间给进程,进程的地址空间是从0开始的一段在逻辑上连续的地址。在物理上不一定连续(取决于操作系统的内存管理方案)。linux的内存管理方案是非连续内存分配方案。

 **为什么需要虚拟存储?**

​		进程地址空间隔离，

​		某些时刻,进程需要的地址空间大小大于物理地址空间的剩余大小。比如某个进程需要20MB的地址空间,但是物理地址只剩8MB了，不足以一次将整个进程地址空间装载到物理内存中,为了解决这个问题,提出了虚拟地址空间的方案,刚刚这个例子，分配给进程的地址空间中,有8MB的逻辑地址是指向了实际的物理地址空间的,剩下的12MB都是虚拟地址空间。



**虚拟内存管理的几种实现**

- 覆盖技术

  一个程序一次只会运行到一个分支,给进程分配内存的时候,按需要内存大的分支分配,而不必全部分配

- 交换技术

  操作系统将长期没有访问的进程的地址空间置换到硬盘上,需要的时候再从硬盘加载到内存中

- 虚存技术

  进程加载到内存中时,给当前运行必须的指令跟数据分配实际的物理内存空间,剩下一部分分配虚拟地址空间虚拟出一段地址空间,当访问到虚拟地址空间时,由操作系统调用页面

**虚存技术可以实现的基础**

​		**程序局部性原理**,程序局部性分为时间局部性和空间局部性，时间局部性是指如果程序中的某条指令被执行过,那么不久之后它很可能会再次被执行。空间局部性是指程序中的某段数据被访问,那么不久之后它可能会再次被访问。即在一段时间内，程序的执行仅集中在程序的某一部分,数据的访问也集中在内存的某一部分。

​		有了程序局部性原理,虚存技术就有了实现的可能，当程序运行时，不必将程序全部装载进内存,而只需要将当前需要执行的页面或段加载至内存,就可让程序正常运行

​		在程序运行过程中，如果cpu执行的指令或访问的数据不在内存中,则会产生一个缺页异常,此时系统会发起调页请求,将数据加载到内存页中,使程序继续运行。每次调页请求都会产生一次从硬盘写入到内存的i/o过程,写程序时应尽量减少调页请求的次数。比如数组在内存中是按行排列的,也就是说一个长度为1024大小的数据就占据了一页(一页默认是4K,也有4M的大页)大小的内存,一个1024x1024大小的二维数组,如果外围按行遍历,内部按列遍历,那么就会产生1024x1024次缺页异常,见下图

```go
var arr = [1024][1024]int{}
for i := 0;i<1024;i++{
    for j:=0;j<1024;j++{
        a[i][j] = 0
    }
}
```

数组的访问过程是
arr0,0 arr0,1 arr0,2 ... ... arr0,1022 arr0,1023
arr1,0 arr1,1 arr1,2 ... ... arr1,1022 arr1,1023
... ... ... ... ... ... .... ... ...
arr1023,0 arr1023,1  ... ... arr1023,1022 arr1023,arr1023
因为数组在内存中是按行存放的,一行占据一页内存,外行内列的遍历方式,理论上每次遍历都会产生一次缺页，整个遍历过程总共会产生1024x1024次缺页异常。如果换成外列内行(先遍历完一行数据,再遍历下一行)的话,则只会产生1024次缺页异常

**虚存的基本特征**

- 大的用户地址空间

  使用虚存的操作系统,每个进程的地址空间最大可以达到,实际物理内存 + 4G虚拟内存(这只是针对32位操作系统而言,因为32位操作系统一次最多可以处理的数据大小就是2的32次方,也就是4G,目前不同操作系统对64位的支持不太一样)

- 部分交换

  虚存的数据交换只发生在虚拟地址空间范围

- 不连续性

  虚拟内存在物理上是不连续的

##### 虚拟存储页式管理方案

​	虚拟页式存储管理方案就是在页式存储管理方案中加入了请求调页和页面置换

**调页方式**

- 请求调页

  当程序运行过程中发生缺页异常时,才装入页面

- 预先调页

  在程序运行过程中,操作系统预计内存会不够用时,会提前加载内存

  